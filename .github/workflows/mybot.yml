name: MyBoT Integration

on:
  pull_request:
  workflow_dispatch:
    inputs:
      apply:
        description: "Apply fixes (true/false)"
        required: false
        default: "false"

permissions:
  contents: write
  pull-requests: write

jobs:
  mybot:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Sanity check OpenAI key
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          code=$(curl -s -o /dev/null -w "%{http_code}" https://api.openai.com/v1/models \
                 -H "Authorization: Bearer $OPENAI_API_KEY")
          echo "OpenAI /v1/models HTTP $code"
          test "$code" = "200"

      - name: Detect context & decide apply mode
        id: ctx
        run: |
          IS_FORK="${{ github.event.pull_request.head.repo.fork && 'true' || 'false' }}"
          echo "is_fork=$IS_FORK" >> "$GITHUB_OUTPUT"
          LABELS="${{ join(github.event.pull_request.labels.*.name, ' ') }}"
          HAS_LABEL="false"
          echo "$LABELS" | grep -q "mybot:apply" && HAS_LABEL="true"
          echo "has_label=$HAS_LABEL" >> "$GITHUB_OUTPUT"
          APPLY_INPUT="${{ inputs.apply }}"
          [ -z "$APPLY_INPUT" ] && APPLY_INPUT="false"
          echo "apply_input=$APPLY_INPUT" >> "$GITHUB_OUTPUT"

      - name: Build changed file list
        id: files
        shell: bash
        run: |
          set -e
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            git fetch origin ${{ github.base_ref }} --depth=1
            DIFF=$(git diff --name-only --diff-filter=AM origin/${{ github.base_ref }}...HEAD || true)
          else
            DIFF=$(git ls-files | head -n 60)
          fi
          FILES=$(echo "$DIFF" | grep -E '\.(py|js|ts|tsx|md|json|yml|yaml|css|html)$' | \
                  grep -Ev '(^$|^node_modules/|^dist/|^build/|^.git/|^.github/)' | head -n 60 || true)
          echo "$FILES" > files.txt
          echo "count=$(wc -l < files.txt | tr -d ' ')" >> "$GITHUB_OUTPUT"

      - name: Analyze & propose patches
        if: ${{ steps.files.outputs.count != '0' }}
        id: propose
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          echo "## MyBoT AI Summary" > summary.md
          echo "" >> summary.md

          gen_prompt () {
            local f="$1"
            local content
            content="$(sed 's/`/\\`/g' "$f" | head -c 48000)"

            POLICY=$'Repository policy:\n- Keep style and architecture consistent.\n- Small, safe changes per file; no sweeping rewrites.\n- Only modify the given file.\n- If no change is needed, do not output a patch.\n\nTask:\n1) Briefly summarize what this file does (<=5 bullets).\n2) Suggest concrete improvements (<=8 bullets).\n3) If improvements are small and safe, output a unified diff for this ONE file only, surrounded by:\nBEGIN_PATCH\n*** Start Patch\n<unified-diff-here>\n*** End Patch\nEND_PATCH'

            jq -n --arg f "$f" --arg c "$content" --arg pol "$POLICY" \
            '{
              model:"gpt-4o-mini",
              messages:[
                {role:"system","content":"You are a meticulous senior software engineer. Output only clear analysis and, when edits are needed, a unified diff patch between BEGIN_PATCH and END_PATCH. Never include explanations inside the patch."},
                {role:"user","content": ($pol + "\n\nFile path: " + $f + "\n----- FILE CONTENT (truncated) -----\n" + $c)}
              ],
              temperature: 0.2,
              max_tokens: 800
            }'
          }

          > patches.diff
          while IFS= read -r f; do
            [ -f "$f" ] || continue
            echo "### $f" >> summary.md
            PROMPT=$(gen_prompt "$f")
            RESP=$(curl -sS https://api.openai.com/v1/chat/completions \
                     -H "Authorization: Bearer $OPENAI_API_KEY" \
                     -H "Content-Type: application/json" \
                     -d "$PROMPT")
            TEXT=$(echo "$RESP" | jq -r '.choices[0].message.content // ""')
            if [ -z "$TEXT" ]; then
              echo "_No AI response._" >> summary.md
              continue
            fi
            echo "$TEXT" >> summary.md
            echo "$TEXT" | awk '/BEGIN_PATCH/{flag=1;next}/END_PATCH/{flag=0}flag' \
              | sed '1,1d;$d' \
              | sed '1,/^\*\*\* Start Patch/d' >> patches.diff
          done < files.txt

          echo "summary_path=summary.md" >> "$GITHUB_OUTPUT"

      - name: Show Summary
        if: ${{ steps.files.outputs.count != '0' }}
        run: |
          cat summary.md >> "$GITHUB_STEP_SUMMARY"

      - name: Apply patches (only if allowed)
        if: ${{ steps.files.outputs.count != '0' && steps.ctx.outputs.is_fork != 'true' && (steps.ctx.outputs.has_label == 'true' || steps.ctx.outputs.apply_input == 'true') }}
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          set -e
          if [ ! -s patches.diff ]; then
            echo "No patch content found. Skipping apply."
            exit 0
          fi

          echo "Attempting to apply patches:"
          echo "--------------------------------"
          cat patches.diff || true
          echo "--------------------------------"

          git config user.name "MyBoT"
          git config user.email "bot@dunetube.local"

          # اگر GH_PAT موجود بود، با PAT پوش می‌کنیم تا ورک‌فلوها تریگر شوند؛ وگرنه با GITHUB_TOKEN
          if [ -n "${GH_PAT:-}" ]; then
            echo "Using GH_PAT for push"
            git remote set-url origin "https://${GH_PAT}@github.com/${GITHUB_REPOSITORY}.git"
          else
            echo "Using default GITHUB_TOKEN for push"
            git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          fi

          if ! grep -q '^--- ' patches.diff; then
            echo "Patch seems incomplete; skipping apply."
            exit 0
          fi

          git apply --index --reject patches.diff || true
          if ! git diff --cached --quiet; then
            git commit -m "chore(mybot): auto-fixes from MyBoT"
            git push
          else
            echo "No staged changes; nothing to commit."
          fi

      - name: Comment on PR
        if: ${{ github.event_name == 'pull_request' && steps.files.outputs.count != '0' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const pr = context.payload.pull_request;
            const isFork = !!(pr && pr.head && pr.head.repo && pr.head.repo.fork);
            const labels = (pr && pr.labels ? pr.labels.map(l => l.name) : []);
            const hasLabel = labels.includes('mybot:apply');

            const header = "### MyBoT AI Summary\n\n";
            const summary = fs.readFileSync('summary.md','utf8');
            const footerLines = [];
            footerLines.push(hasLabel ? "Label `mybot:apply` present" : "Label `mybot:apply` missing");
            if (isFork) footerLines.push("**Fork PR:** cannot apply patches automatically.");
            const body = header + summary + "\n" + footerLines.join("\n") + "\n";

            const {owner, repo} = context.repo;
            const issue_number = pr.number;
            const comments = await github.rest.issues.listComments({owner, repo, issue_number});
            const existing = comments.data.find(c => c.body && c.body.startsWith("### MyBoT AI Summary"));
            if (existing) {
              await github.rest.issues.updateComment({owner, repo, comment_id: existing.id, body});
            } else {
              await github.rest.issues.createComment({owner, repo, issue_number, body});
            }
