name: MyBoT Integration

on:
  push:
    branches: [ "main" ]
  pull_request:
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write

jobs:
  run-mybot:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Show repo & manifest
        run: |
          echo "## 📁 Repo tree (top-level)" >> "$GITHUB_STEP_SUMMARY"
          ls -la | sed 's/^/    /' >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "## 📄 MyBoT manifest" >> "$GITHUB_STEP_SUMMARY"
          echo '```yaml' >> "$GITHUB_STEP_SUMMARY"
          cat MyBoT/manifest.yaml >> "$GITHUB_STEP_SUMMARY" || echo "manifest.yaml not found" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - name: Build file list
        id: files
        shell: bash
        run: |
          set -e
          # اگر PR است، فقط فایل‌های تغییرکرده را بگیر
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            git fetch origin ${{ github.base_ref }} --depth=1
            DIFF=$(git diff --name-only --diff-filter=AM origin/${{ github.base_ref }}...HEAD)
          else
            # در push/دستی: مجموعه‌ای معقول از فایل‌های مرتبط
            DIFF=$(git ls-files | grep -E '\.(md|py|js|ts|tsx|json|yml|yaml)$' | head -n 60)
          fi

          # حذف مسیرهای غیرضروری
          FILES=$(echo "$DIFF" | grep -Ev '(^$|^node_modules/|^dist/|^build/|^.git/|^.github/)' || true)

          echo "These files will be analyzed:"
          echo "$FILES"
          echo "$FILES" > files.txt

          # خروجی برای steps بعدی
          echo "count=$(wc -l < files.txt | tr -d ' ')" >> $GITHUB_OUTPUT

      - name: Analyze with OpenAI
        if: steps.files.outputs.count != '0'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        shell: bash
        run: |
          set -e
          echo "## 🤖 MyBoT AI Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          summarize_chunk () {
            local path="$1"
            local chunk="$2"
            local tries=0
            local maxtries=3
            local delay=2
            local payload
            payload=$(jq -n --arg f "$path" --arg c "$chunk" \
              '{model:"gpt-4o-mini",
                messages:[
                  {role:"system",content:"You are a senior repo analysis assistant."},
                  {role:"user",content:("Summarize the content and propose up to 8 concrete improvements. File: "+$f+"\n---\n"+$c)}
                ],
                max_tokens: 350}')

            while : ; do
              resp=$(curl -sS https://api.openai.com/v1/chat/completions \
                       -H "Authorization: Bearer '"$OPENAI_API_KEY"'" \
                       -H "Content-Type: application/json" \
                       -d "$payload" || true)
              text=$(echo "$resp" | jq -r '.choices[0].message.content // empty')
              if [ -n "$text" ]; then
                echo "$text"
                return 0
              fi
              tries=$((tries+1))
              if [ "$tries" -ge "$maxtries" ]; then
                echo "⚠️ No AI response after $maxtries tries."
                echo "Raw error:" 
                echo "$resp" | jq -r '.error.message // . | tostring' 2>/dev/null || echo "$resp"
                return 0
              fi
              sleep "$delay"
            done
          }

          summarize_file () {
            local path="$1"
            echo "### $path" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"

            # اگر فایل خیلی بزرگ بود، به تکه‌های ~6000 کاراکتری بشکن
            local content
            content="$(sed 's/`/\\`/g' "$path" | head -c 48000)"
            if [ -z "$content" ]; then
              echo "_(empty or binary?)_" >> "$GITHUB_STEP_SUMMARY"
              echo "" >> "$GITHUB_STEP_SUMMARY"
              return
            fi

            # chunking
            echo "$content" | awk -v size=6000 '{
              s=$0
              while (length(s) > 0) {
                print substr(s,1,size)
                s=substr(s,size+1)
              }
            }' > chunks.tmp

            chunk_idx=0
            while IFS= read -r chunk; do
              chunk_idx=$((chunk_idx+1))
              echo "**Part $chunk_idx**" >> "$GITHUB_STEP_SUMMARY"
              summarize_chunk "$path" "$chunk" >> "$GITHUB_STEP_SUMMARY"
              echo "" >> "$GITHUB_STEP_SUMMARY"
              # حداکثر 3 تکه برای هر فایل
              if [ "$chunk_idx" -ge 3 ]; then
                echo "_(truncated after 3 parts)_" >> "$GITHUB_STEP_SUMMARY"
                break
              fi
            done < chunks.tmp
            rm -f chunks.tmp
          }

          while IFS= read -r f; do
            [ -f "$f" ] && summarize_file "$f" || true
          done < files.txt

          echo "✅ MyBoT completed AI analysis." >> "$GITHUB_STEP_SUMMARY"

      - name: Prepare PR comment body
        if: github.event_name == 'pull_request' && steps.files.outputs.count != '0'
        run: |
          echo "### 🤖 MyBoT AI Summary" > pr-comment.md
          echo "" >> pr-comment.md
          echo "_See full details in the Actions run summary._" >> pr-comment.md

      - name: Comment on PR
        if: github.event_name == 'pull_request' && steps.files.outputs.count != '0'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('pr-comment.md', 'utf8');
            const {owner, repo} = context.repo;
            const issue_number = context.payload.pull_request.number;

            // سعی می‌کنیم اگر قبلاً کامنتی با این عنوان بوده، آپدیتش کنیم
            const header = "### 🤖 MyBoT AI Summary";
            const comments = await github.rest.issues.listComments({owner, repo, issue_number});
            const existing = comments.data.find(c => c.body && c.body.startsWith(header));
            if (existing) {
              await github.rest.issues.updateComment({owner, repo, comment_id: existing.id, body});
            } else {
              await github.rest.issues.createComment({owner, repo, issue_number, body});
            }
